import { useState, useEffect, useCallback, useMemo } from 'react';
import { apiService, ApiEntry } from '@/lib/apiService';
import { Company, Category, Entry } from '@/lib/supabase';
import { HierarchyMiddleware, HierarchicalCategory, ProcessedEntry } from '@/lib/hierarchyMiddleware';

// Simplified state management for Supabase integration with 3-level hierarchy
export interface FinCalSupabaseState {
  companies: Company[];
  hierarchicalCategories: HierarchicalCategory[]; // NEW: Using processed hierarchy
  entries: ProcessedEntry[]; // NEW: Using processed entries
  activeCompanyId: string | null;
  currentYear: number;
  currentMonth: number;
  loading: boolean;
  error: string | null;
}

// Convert Backend API response to frontend hierarchical format
const convertBackendToHierarchical = (backendSummary: any): HierarchicalCategory[] => {
  const hierarchicalCategories: HierarchicalCategory[] = [];
  
  // Process combined data (has both consolidated and projections)
  const combinedData = backendSummary.combined;
  if (!combinedData || !combinedData.categories) return hierarchicalCategories;
  
  // Convert each category from backend format
  Object.entries(combinedData.categories).forEach(([categoryName, categoryData]: [string, any]) => {
    // Skip special calculated categories
    if (categoryName.includes('DIFF.') || categoryName.includes('CASH FLOW')) return;
    
    const hierarchicalCategory: HierarchicalCategory = {
      id: categoryName.toLowerCase().replace(/\s+/g, '-'), // Generate ID from name
      name: categoryName,
      type_id: categoryData.type as 'revenue' | 'expense' | 'balance' | 'financing',
      is_calculated: false,
      sort_order: 0,
      hasSubcategories: false,
      subcategories: [],
      entries: [], // We'll populate this if needed
      monthlyTotals: {} // We'll populate from monthly_data if available
    };
    
    // Add monthly totals if available
    if (combinedData.monthly_data) {
      Object.entries(combinedData.monthly_data).forEach(([month, monthData]: [string, any]) => {
        const monthKey = `${backendSummary.year}-${month}`;
        
        // For now, we distribute the total across months proportionally
        // This is a simplification - in reality we'd need detailed monthly data
        if (categoryData.type === 'revenue' && monthData.revenue) {
          hierarchicalCategory.monthlyTotals[monthKey] = categoryData.total / 12; // Simple distribution
        } else if (categoryData.type === 'expense' && monthData.expenses) {
          hierarchicalCategory.monthlyTotals[monthKey] = categoryData.total / 12; // Simple distribution
        }
      });
    }
    
    hierarchicalCategories.push(hierarchicalCategory);
  });
  
  return hierarchicalCategories;
};

export const useFinCalSupabase = () => {
  const [state, setState] = useState<FinCalSupabaseState>({
    companies: [],
    hierarchicalCategories: [],
    entries: [],
    activeCompanyId: null,
    currentYear: 2025,
    currentMonth: 7,
    loading: true,
    error: null
  });

  // Initialize or get ORTI company - USING BACKEND API
  const initializeORTI = useCallback(async () => {
    try {
      console.log('ðŸš€ Starting ORTI initialization via Backend API...');
      setState(prev => ({ ...prev, loading: true, error: null }));
      
      // Use Backend API instead of direct Supabase
      console.log('ðŸ“Š Getting company data from Backend API...');
      const response = await fetch(`http://localhost:8000/companies/ORTI/summary/${state.currentYear}?include_projections=true`);
      
      if (!response.ok) {
        throw new Error(`Backend API error: ${response.status} ${response.statusText}`);
      }
      
      const backendData = await response.json();
      console.log('ðŸ¢ Backend response:', backendData);
      
      if (!backendData.success) {
        throw new Error('Backend returned unsuccessful response');
      }
      
      // Convert backend data to hierarchical format
      console.log('ðŸ—ï¸ Converting backend data to hierarchical format...');
      const hierarchicalCategories = convertBackendToHierarchical(backendData.summary);
      console.log(`âœ… Loaded ${hierarchicalCategories.length} hierarchical categories`);
      
      // Extract all entries from hierarchy for compatibility
      const allEntries: ProcessedEntry[] = [];
      hierarchicalCategories.forEach(category => {
        allEntries.push(...category.entries);
      });
      console.log(`âœ… Extracted ${allEntries.length} processed entries`);
      
      // Set final state
      console.log('ðŸŽ¯ Setting final state...');
      setState(prev => ({
        ...prev,
        companies: [{id: 'orti-backend', name: 'ORTI', description: 'ORTI Company via Backend API'}],
        hierarchicalCategories,
        entries: allEntries,
        activeCompanyId: 'orti-backend',
        loading: false
      }));
      
      console.log('ðŸŽ‰ ORTI initialization completed successfully!');
      
    } catch (error) {
      console.error('âŒ Error initializing ORTI:', {
        message: error?.message || String(error),
        name: error?.name || 'Unknown',
        stack: error?.stack
      });
      setState(prev => ({ 
        ...prev, 
        loading: false, 
        error: error instanceof Error ? error.message : 'Failed to initialize' 
      }));
    }
  }, [state.currentYear]);

  // Load data on mount and when year changes
  useEffect(() => {
    initializeORTI();
  }, [initializeORTI]);

  // Get active company
  const activeCompany = useMemo(() => {
    return state.companies.find(c => c.id === state.activeCompanyId) || null;
  }, [state.companies, state.activeCompanyId]);

  // Update entry - FIXED for 3-level hierarchy
  const updateEntry = useCallback(async (
    categoryId: string, 
    subcategoryName: string | null, // NEW: Can specify subcategory name
    monthYear: string, 
    value: number, 
    isProjection: boolean = false, 
    notes?: string
  ) => {
    try {
      const [month, year] = monthYear.split('-').map(Number);
      
      console.log('ðŸ”„ Updating entry:', { categoryId, subcategoryName, year, month, value });
      
      // Use HierarchyMiddleware to handle the complexity
      await HierarchyMiddleware.upsertEntry(
        categoryId,
        subcategoryName,
        year,
        month,
        value,
        isProjection,
        notes
      );
      
      // Refresh data after update
      if (activeCompany) {
        console.log('ðŸ”„ Refreshing data after update...');
        const hierarchicalCategories = await HierarchyMiddleware.loadCompanyHierarchy(activeCompany.id, state.currentYear);
        
        // Extract all entries for compatibility
        const allEntries: ProcessedEntry[] = [];
        hierarchicalCategories.forEach(category => {
          allEntries.push(...category.entries);
        });
        
        setState(prev => ({ 
          ...prev, 
          hierarchicalCategories,
          entries: allEntries 
        }));
        
        console.log('âœ… Data refreshed successfully');
      }
      
    } catch (error) {
      console.error('âŒ Error updating entry:', error);
      setState(prev => ({ 
        ...prev, 
        error: error instanceof Error ? error.message : 'Failed to update entry' 
      }));
    }
  }, [state.currentYear, activeCompany]);

  // Delete entry - FIXED for subcategory_id
  const deleteEntry = useCallback(async (subcategoryId: string, year: number, month: number) => {
    try {
      console.log('ðŸ—‘ï¸ Deleting entry:', { subcategoryId, year, month });
      
      await HierarchyMiddleware.deleteEntry(subcategoryId, year, month);
      
      // Refresh data after deletion
      if (activeCompany) {
        console.log('ðŸ”„ Refreshing data after deletion...');
        const hierarchicalCategories = await HierarchyMiddleware.loadCompanyHierarchy(activeCompany.id, state.currentYear);
        
        const allEntries: ProcessedEntry[] = [];
        hierarchicalCategories.forEach(category => {
          allEntries.push(...category.entries);
        });
        
        setState(prev => ({ 
          ...prev, 
          hierarchicalCategories,
          entries: allEntries 
        }));
        
        console.log('âœ… Data refreshed after deletion');
      }
      
    } catch (error) {
      console.error('âŒ Error deleting entry:', error);
      setState(prev => ({ 
        ...prev, 
        error: error instanceof Error ? error.message : 'Failed to delete entry' 
      }));
    }
  }, [state.currentYear, activeCompany]);

  // Get monthly totals - UPDATED for new hierarchy
  const getMonthlyTotals = useCallback((monthYear: string) => {
    const [month, year] = monthYear.split('-').map(Number);
    
    const totals = {
      revenue: 0,
      expense: 0,
      balance: 0,
      financing: 0,
      netCashFlow: 0
    };
    
    // Calculate totals from hierarchical categories
    state.hierarchicalCategories.forEach(category => {
      const monthKey = monthYear;
      const categoryTotal = category.monthlyTotals[monthKey] || 0;
      
      if (category.type_id in totals) {
        totals[category.type_id as keyof typeof totals] += categoryTotal;
        }
      });
    
    totals.netCashFlow = totals.revenue - totals.expense;
    
    return totals;
  }, [state.hierarchicalCategories]);

  // Get category by ID - NEW helper
  const getCategoryById = useCallback((categoryId: string): HierarchicalCategory | null => {
    return state.hierarchicalCategories.find(cat => cat.id === categoryId) || null;
  }, [state.hierarchicalCategories]);

  // Get entries for a specific category - NEW helper
  const getCategoryEntries = useCallback((categoryId: string): ProcessedEntry[] => {
    const category = getCategoryById(categoryId);
    return category ? category.entries : [];
  }, [getCategoryById]);

  // Backward compatibility: categories array (flattened from hierarchy)
  const compatibilityCategories = useMemo(() => {
    return state.hierarchicalCategories.map(hcat => ({
      id: hcat.id,
      name: hcat.name,
      type_id: hcat.type_id,
      is_total: hcat.is_total,
      is_calculated: hcat.is_calculated,
      sort_order: hcat.sort_order,
      company_id: state.activeCompanyId || '',
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString(),
      calculation_formula: undefined
    } as Category));
  }, [state.hierarchicalCategories, state.activeCompanyId]);

  return {
    // State
    companies: state.companies,
    categories: compatibilityCategories, // Backward compatibility
    hierarchicalCategories: state.hierarchicalCategories, // NEW: Full hierarchy
    entries: state.entries,
    activeCompany,
    currentYear: state.currentYear,
    currentMonth: state.currentMonth,
    loading: state.loading,
    error: state.error,
    
    // Actions - UPDATED for 3-level hierarchy
    updateEntry,
    deleteEntry, // NEW: Delete with subcategory_id
    getMonthlyTotals,
    
    // NEW: Hierarchy helpers
    getCategoryById,
    getCategoryEntries,
    
    // Existing methods
    initializeORTI,
    
    // State management
    setCurrentYear: (year: number) => {
      setState(prev => ({ ...prev, currentYear: year }));
      // Auto-refresh when year changes
      if (state.activeCompanyId) {
        initializeORTI();
      }
    },
    setCurrentMonth: (month: number) => setState(prev => ({ ...prev, currentMonth: month })),
    clearError: () => setState(prev => ({ ...prev, error: null }))
  };
}; 