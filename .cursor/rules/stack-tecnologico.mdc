---
alwaysApply: true
---

globs: orti-finance-api/**/*.py, **/*.sqlalwaysApply: falsedescription: Regole per la gestione del database Supabase di ORTI Finance, con struttura gerarchica ottimizzata, real-time sync e sicurezza RLS.
Regole Database Ottimizzate (ORTI Finance v3.0)
Struttura Gerarchica

Tabelle Principali:
companies: Anagrafica delle società (es. 'ORTI' con id, name, description).
categories: Macro-voci di primo livello (es. 'Entrate Hotel', 'Salari e Stipendi'). Include type_id (revenue, expense, balance) e sort_order per ordinamento.
subcategories: Dettagli di una categoria (es. 'Energia Elettrica' sotto 'Utenze'). Include category_id (UUID) e sort_order.
entries: Tabella chiave per valori finanziari. Contiene:
subcategory_id (UUID, riferimento a subcategories).
year (es. 2025).
month (1-12).
value (numerico, es. 1454947 per entrate).
is_projection (boolean: false per dati reali, true per previsioni).
notes (opzionale, testo descrittivo).





Struttura Ottimizzata

Entrate: Semplificate a 1 livello (es. 'Entrate Hotel', 'Entrate Residence', 'Caparre Intur'). Subcategoria default: 'Main' (sort_order=1).
Uscite: Organizzate a 2 livelli (es. 'Utenze' → 'Energia Elettrica', 'Gas'; 'Tasse e Imposte' → 'IMU, IMPOSTE, IVA').
Saldi: Subcategoria 'Saldo' per conti bancari (es. 'Saldo MPS', 'Saldo Intesa').
Caratteristiche:
Eliminati duplicati per maggiore chiarezza.
Compatibile con backend FastAPI e frontend real-time.
Definita in reset_database.sql (idempotente) e ottimizzata in populate_orti_data_optimized.sql (entrate 1 livello, uscite 2 livelli).



Sicurezza

Row Level Security (RLS): Abilitata su entries per protezione dati:
Lettura: Accesso per tutti (SELECT USING (true)).
Scrittura: Riservata agli utenti autenticati (ALL USING (auth.role() = 'authenticated')).

ALTER TABLE entries ENABLE ROW LEVEL SECURITY;
CREATE POLICY "read_all" ON entries FOR SELECT USING (true);
CREATE POLICY "write_authenticated" ON entries FOR ALL USING (auth.role() = 'authenticated');


UUID: Usa sempre subcategory_id (UUID) per riferimenti al database, mai slug (es. 'entrate-hotel').

Query e Real-Time

Query Ottimizzate:
Usa inner joins per aggregazioni efficienti (es. in supabase_service.py):result = self.client.table("entries").select("*, subcategories!inner(name, categories!inner(name, type_id))")\
    .eq("subcategories.categories.company_id", company_id).execute()


RPC per totali mensili (es. get_monthly_totals in supabase_service.py).


Real-Time Sync:
Implementa subscriptions Supabase su postgres_changes per aggiornamenti automatici:supabase.channel('entries-changes')
  .on('postgres_changes', { event: '*', schema: 'public', table: 'entries' }, 
      (payload) => { refreshFinancialData(); })
  .subscribe();


Usato in useFinancialDataRealtime.ts per refresh UI post-mutazione, eliminando polling.



Best Practices

Idempotenza: Esegui reset_database.sql con ./orti db:reset per pulizia e ripopolamento sicuro.
Consistenza:
Verifica is_projection per distinguere dati reali (false) da previsioni (true).
Crea subcategoria 'Main' per categorie senza sottocategorie (sort_order=1).


Gestione Errori:
Errore "invalid uuid": Usa UUID, non slug.
Errore "subcategory undefined": Verifica/crea subcategoria 'Main' prima di insert.


Importazione Dati:
Usa import_historical_revenues o import_monthly_data in supabase_service.py per caricare dati con flag is_projection corretto.



Riferimenti

Script SQL:
reset_database.sql: Pulizia e popolazione iniziale di 'ORTI' (idempotente).
populate_orti_data_optimized.sql: Struttura ottimizzata (entrate 1 livello, uscite 2 livelli).


Codice:
supabase_service.py: Logica di accesso DB (es. upsert_entry, get_monthly_totals).
useFinCalSupabase.ts: Pattern CRUD frontend con real-time.


